"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AngularEslintLintMigrator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const devkit_2 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const path_1 = require("path");
const utilities_1 = require("../../utilities");
const builder_migrator_1 = require("./builder.migrator");
class AngularEslintLintMigrator extends builder_migrator_1.BuilderMigrator {
    constructor(tree, project, projectConfig, logger) {
        super(tree, '@angular-eslint/builder:lint', 'eslint', project, projectConfig, logger);
    }
    migrate() {
        var _a, _b;
        for (const [name, target] of this.targets) {
            this.oldEsLintConfigPath =
                (_b = (_a = target.options) === null || _a === void 0 ? void 0 : _a.eslintConfig) !== null && _b !== void 0 ? _b : (0, devkit_2.joinPathFragments)(this.project.oldRoot, '.eslintrc.json');
            this.newEsLintConfigPath = this.convertRootPath(this.oldEsLintConfigPath);
            this.moveProjectRootFile(this.oldEsLintConfigPath);
            this.updateTargetConfiguration(name, target);
            this.updateEsLintConfig();
            this.updateCacheableOperations([name]);
        }
        if (!this.targets.size && this.projectConfig.root === '') {
            // there could still be a .eslintrc.json file in the root
            // so move to new location
            const eslintConfig = '.eslintrc.json';
            if (this.tree.exists(eslintConfig)) {
                this.logger.info('No "lint" target was found, but an ESLint config file was found in the project root. The file will be moved to the new location.');
                this.moveProjectRootFile(eslintConfig);
            }
        }
    }
    validate() {
        const errors = [];
        // TODO(leo): keeping restriction until the full refactor is done and we start
        // expanding what's supported.
        if (this.targets.size > 1) {
            errors.push({
                message: `There is more than one target using a builder that is used to lint the project (${(0, utilities_1.arrayToString)([...this.targets.keys()])}).`,
                hint: `Make sure the project only has one target with a builder that is used to lint the project.`,
            });
        }
        return errors.length ? errors : null;
    }
    updateTargetConfiguration(targetName, target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            target.executor = '@nrwl/linter:eslint';
            if (!target.options) {
                this.logger.warn(`The target "${targetName}" is not specifying any options. Skipping updating the target configuration.`);
                return;
            }
            const existEsLintConfigPath = this.tree.exists(this.newEsLintConfigPath);
            if (!existEsLintConfigPath) {
                this.logger.warn(`The ESLint config file "${this.oldEsLintConfigPath}" could not be found. Skipping updating the file.`);
            }
            target.options.eslintConfig =
                target.options.eslintConfig && this.newEsLintConfigPath;
            target.options.lintFilePatterns =
                target.options.lintFilePatterns &&
                    target.options.lintFilePatterns.map((pattern) => {
                        // replace the old source root with the new root, we want to lint all
                        // matching files in the project, not just the ones in the source root
                        if (pattern.startsWith(this.project.oldSourceRoot)) {
                            return (0, devkit_2.joinPathFragments)(this.project.newRoot, pattern.replace(this.project.oldSourceRoot, ''));
                        }
                        // replace the old root with the new root
                        if (pattern.startsWith(this.project.oldRoot)) {
                            return (0, devkit_2.joinPathFragments)(this.project.newRoot, pattern.replace(this.project.oldRoot, ''));
                        }
                        // do nothing, warn about the pattern
                        this.logger.warn(`The lint file pattern "${pattern}" specified in the "${targetName}" target is not contained in the project root or source root. The pattern will not be updated.`);
                        return pattern;
                    });
            if (existEsLintConfigPath) {
                const eslintConfig = (0, devkit_2.readJson)(this.tree, this.newEsLintConfigPath);
                if ((0, linter_1.hasRulesRequiringTypeChecking)(eslintConfig)) {
                    target.options.hasTypeAwareRules = true;
                }
            }
            (0, devkit_2.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
        });
    }
    updateEsLintConfig() {
        if (!this.tree.exists(this.newEsLintConfigPath)) {
            return;
        }
        (0, devkit_1.updateJson)(this.tree, this.newEsLintConfigPath, (json) => {
            var _a;
            delete json.root;
            json.ignorePatterns = ['!**/*'];
            const rootEsLintConfigRelativePath = (0, devkit_2.joinPathFragments)((0, devkit_2.offsetFromRoot)(this.projectConfig.root), '.eslintrc.json');
            if (Array.isArray(json.extends)) {
                json.extends = json.extends.map((extend) => this.convertEsLintConfigExtendToNewPath(this.oldEsLintConfigPath, extend));
                // it might have not been extending from the root config, make sure it does
                if (!json.extends.includes(rootEsLintConfigRelativePath)) {
                    json.extends.unshift(rootEsLintConfigRelativePath);
                }
            }
            else {
                json.extends = rootEsLintConfigRelativePath;
            }
            (_a = json.overrides) === null || _a === void 0 ? void 0 : _a.forEach((override) => {
                var _a;
                if (!((_a = override.parserOptions) === null || _a === void 0 ? void 0 : _a.project)) {
                    return;
                }
                override.parserOptions.project = [
                    `${this.projectConfig.root}/tsconfig.*?.json`,
                ];
            });
            return json;
        });
    }
    convertEsLintConfigExtendToNewPath(eslintConfigPath, extendPath) {
        if (!extendPath.startsWith('..')) {
            // we only need to adjust paths that are on a different directory, files
            // in the same directory are moved together so their relative paths are
            // not changed
            return extendPath;
        }
        return (0, devkit_2.joinPathFragments)((0, devkit_2.offsetFromRoot)(this.project.newRoot), (0, path_1.dirname)(eslintConfigPath), extendPath);
    }
}
exports.AngularEslintLintMigrator = AngularEslintLintMigrator;
//# sourceMappingURL=angular-eslint-lint.migrator.js.map